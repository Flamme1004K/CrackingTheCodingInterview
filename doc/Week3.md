# 배열과 문자열, 연결리스트 읽기

## 해시 테이블(Hash Table)

https://www.youtube.com/watch?v=Vi0hauJemxA


키(Key), 값(value)에 대응시킨다.

해시 테이블을 구현하기 위해서는 연결리스트(Linked List)와 해시 코드 함수(Hash code function)이 있어야 한다.

만들어진 HashCode는 정수이다.

해시 코드를 이용하여 direct로 배열에 접근할 수 있기 때문에 속도가 빠르다.

해슁? https://itstory.tk/entry/%ED%95%B4%EC%8A%81Hashing-%ED%95%B4%EC%89%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%95%B4%EC%89%AC-%ED%95%A8%EC%88%98

###  키와 상응하는 값을 찾는 방법

1. 키의 해시 코드를 계산한다. 
2. Hash(Key) % array_length와 같은 방식으로 해시 코드를 이용해 배열의 인덱스를 구한다. 
3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다.

--> 서로 다른 두개의 키가 같은 해시 코드를 가르키거나 서로 다른 두 개의 해시코드가 같은 인덱스를 카리키는 경우 충돌이 일어날 수 있으므로 연결리스트를 이용한다.

--> 얼마나 잘 분배하냐에 따라서 속도가 달라진다.
### 요약 : 
1. 주어진 키로부터 해시 코드를 계산
2. 해당 해시 코드를 이용하여 인덱스 계산
3. 해당 키에 상응하는 값을 연결리스트에서 탐색

충돌이 자주 발생한다면, 최악의 경우의 수행시간(worst case runtime)은 O(N)이 된다. 충돌이 최소화 된다면 O(1)이 된다.

--> 사용하는 해싱충돌은 체이닝을 사용하여 해결한다.

--> 좋은 해싱 함수의 알고리즘 : 1. 분배가 잘되는 것, 만약 해싱함수를 구현하게 된다면 소수를 사용하라. 소수에서도 멱수에 해당하지 않는 소수를 사용하라.


### 균형 이진 탐색 트리(balanced binary search tree)
1. 탐색 시간은 O(logN)
2. 크기가 큰 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용
3. 키의 집합을 특정 순서로 차례대로 접근 가능.

### ArrayList와 가변 크기 배열

1. 동적 가변 크기 기능이 내제되어 있는 배열과 비슷한 자료구조를 원할 때는 보통 ArrayList를 사용한다.
2. 필요에 따라 크기를 변화시킬 수 있으면서도 O(1)의 접근 시간(access time)을 유지한다.
3. 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다.
4. 크기를 두 배 늘리는 시간은 O(n)이지만, 자주 발생하는 일이 아니라서 상환 입력 시간(amortized insertion time)으로 계산했을 때 여전히 O(1)이 된다.

### 상환 입력 시간은 왜 O(1)이 되는가?

## 연결리스트(Linked List)

연결리스트는 차례로 연결된 노드를 표현해주는 자료구조이다.

- 단방향 연결리스트 : 각 노드는 다음 노드를 가리킨다.

- 양방향 연결리스트 : 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

배열과는 달리 연결리스트에서는 특정 인덱스를 상수 시간에 접근할 수 없다. 즉 K번째 원소를 찾고 싶다면 처음부터 K번 루프를 돌아야 한다.

연결리스트의 장점은 리스트의 시작 시점에서 아이템을 추가하거나 삭제하는 연산을 상수 시간에 할 수 있다는 점이다. 

### 연결 리스트 만들기
### 단방향 연결리스트에서 노드 삭제
- 노드 N이 주어지면, 그 이전 노드 prev를 찾아 prev.next를 n.next와 같도록 설정한다.
-  리스트가 양방향 연결 리스트인 경우 n.next가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정한다.
 
 주의점 : 
 - 널 포인터 검사 할 것
 - head와 tail 포인터도 갱신한다.
 
#### Array와 LinkedList의 차이

- Array 같은 경우는 메모리에 공간이 정해져있고, remove나 push를 하였을때 공간 자체(만약 메모리가 차면 메모리 공간을 다시 만들어주기 위함.)
를 새롭게 할당을하고 메모리 추가 삭제가 시작된다.
- Array에서 중간에 삭제를 하면 빈공간이 생기므로, 메모리 파편화가 생긴다.(?)
- LinkedList는 각 노드에 대한 연결을 한다.




### Runner 기법
Runner는 연결리스트 문제에서 많이 활용되는 기법이다.

연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것이다.

https://sina-sina.tistory.com/44

### 재귀 문제
재귀 문제는 O(n)만큼의 공간을 사용한다.
  
### 해시충돌
다른 내용의 데이터가 같은 키를 갖는 것.

데이터가 같은 키를 갖는다는 것은 특정 키가 같은 버켓에 집중되어진다는 것이다. --> 이 이유 때문에 해시충돌이 너무 많이 일어나면 해시테이블의 성능을 떨어트리는 것이다.

해시함수를 정의해서 해시 충돌을 최소화 해야하는 것이 방법이다.

그러면 해시 충돌을 최소화 하는 방법은 무엇일까? 821P

배열은 시작 주소 + (영역 사이즈 * N) = 접근하려는 메모리 구조를 가지게 된다. 이것이 포인트이다.

배열을 추가하면 reallocation이 적용된다. reallocation이란 StringBuilder에서의 System.copy를 생각하면 된다.

즉 기존 공간 배열을 새로운 공간에 복사하는 것이다.
