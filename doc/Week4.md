# 스택과 큐

## 스택 구현하기

스택 자료구조 : 데이터를 쌓아 올린다.

문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법이다.

스택은 LIFO(Last-In-First_Out)에 따라 자료를 배열한다.

### 스택의 기본 연산
- pop() : 스택에서 가장 위에 있는 항목을 제거한다.
- push(item) : item 하나를 스태그이 가장 윗 부분에 추가한다.
- peek() : 스택의 가장 위에 있는 항목을 반환한다.
- isEmpty() : 스택이 비어 있을 때에 true를 반환한다.

배열과 달리 스택은 상수 시간에 i 번째 항목에 접근할 수 없다. 

하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.

즉, 배열처럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.

스택은 같은 방향에서 아이템을 추가하고 삭제한다는 조건하에 연결리스트로 구현할 수 있다.

### 스택이 유용한 경우

#### 재귀 알고리즘을 사용할 때.

재귀적으로 함수를 호출해야 하는 경우 임시 데이터를 스택에 넣어주고, 재귀 함수를 빠져 나와 퇴각 검색(backstack)을 할 때는
스택에 넣어 두었던 임시 데이터를 빼줘야 한다.

스택은 이런 이련의 행위를 직관적으로 가능하게 해준다.

#### 재귀 알고리즘을 반복적 형태(iterative)를 통해서 구현할 수 있게 해준다. 

## 큐 구현하기 

큐는 FIFO(First-In-First-Out) 순서를 따른다. 

매표소 앞에 서 있는 사람들이 움직이는 형태와 같이 큐에 저장되는 항목들은 큐에 추가되는 순서대로 제거된다.

큐는 앞 뒤로 주소를 알고 있어야 한다.(frist, last)

### 큐의 기본 연산

- add(item) : item을 리스트의 끝부분에 추가한다.
- remove() : 리스트의 첫 번째 항목을 제거한다.
- peek() : 큐에서 가장 위에 있는 항목을 반환한다.
- isEmpty() : 큐가 비어 있을 때에 true를 반환한다.

큐 또한 연결리스트로 구현 할 수 있다.

연결리스트의 반대 방향에서 항목을 추가하거나 제거하도록 구현한다면 근본적으로 큐와 같다.

큐를 구현할 때 처음과 마지막 노드를 갱신할 때 실수가 나오기 쉽다.

큐는 너비 우선 탐색(breadth-first search)을 하거나 캐시를 구현하는 경우에 종종 사용된다.

### 너비 우선 탐색(breadth-first search)

처리해야할 노드의 리스트를 저장하는 용도로 큐를 사용

노드를 하나 처리할 때마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다.

--> 노드를 접근한 순서대로 처리할 수 있게 된다.

